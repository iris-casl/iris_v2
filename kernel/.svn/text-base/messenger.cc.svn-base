#ifndef NO_MPI

#include <iostream>
#include <stdlib.h>
#include <assert.h>

#include "messenger.h"

using namespace std;

namespace manifold {
namespace kernel {

//====================================================================
//====================================================================
const int MSG_TAG = 12;  //just a number.


//====================================================================
//====================================================================
void Messenger :: init(int argc, char** argv)
{
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &m_nodeId);
    MPI_Comm_size(MPI_COMM_WORLD, &m_nodeSize);

    m_irecv_started = false;
}

//====================================================================
//====================================================================
void Messenger :: barrier()
{
    MPI_Barrier(MPI_COMM_WORLD);
}

//====================================================================
//! Perform an AllGater.
//! @param item   address of the data to send
//! @param itemSize    size of the data in terms of bytes
//! @param recvbuf    this is where the gathered data are stored
//====================================================================
void Messenger :: allGather(char* item, int itemSize, char* recvbuf)
{
    MPI_Allgather(item, itemSize, MPI_BYTE, recvbuf,
                  itemSize, MPI_BYTE, MPI_COMM_WORLD);
}


//====================================================================
//====================================================================
void Messenger :: send_uint32_msg(int dest, int compIndex, int inputIndex,
				  Ticks_t sendTick, Ticks_t recvTick, uint32_t data)
{
    char buf[MAX_MSG_SIZE];  

    unsigned msg_type = Message_s :: M_UINT32;
    int isTick = 1;  //time unit for sendTime/recvTime is tick

    int position = 0;

    MPI_Pack(&msg_type, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&compIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&inputIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&isTick, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    //Ticks_t == uint64_t
    MPI_Pack(&sendTick, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&recvTick, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&data, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);

    send_message(dest, buf, position);

    #ifdef DBG_MSG
    #endif

}

//====================================================================
//====================================================================
void Messenger :: send_uint32_msg(int dest, int compIndex, int inputIndex,
                                  double sendTime, double recvTime, uint32_t data)
{
    char buf[MAX_MSG_SIZE];  

    unsigned msg_type = Message_s :: M_UINT32;
    int isTick = 0;  //time unit for sendTime/recvTime is not tick

    int position = 0;

    MPI_Pack(&msg_type, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&compIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&inputIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&isTick, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&sendTime, 1, MPI_DOUBLE, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&recvTime, 1, MPI_DOUBLE, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&data, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);

    send_message(dest, buf, position);

    #ifdef DBG_MSG
    #endif

}


//====================================================================
//====================================================================
void Messenger :: send_uint64_msg(int dest, int compIndex, int inputIndex,
				  Ticks_t sendTick, Ticks_t recvTick, uint64_t data)
{
    char buf[MAX_MSG_SIZE];  

    unsigned msg_type = Message_s :: M_UINT64;
    int isTick = 1;  //time unit for sendTime/recvTime is tick

    int position = 0;

    MPI_Pack(&msg_type, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&compIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&inputIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&isTick, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    //Ticks_t == uint64_t
    MPI_Pack(&sendTick, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&recvTick, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&data, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);

    send_message(dest, buf, position);

    #ifdef DBG_MSG
    #endif

}

//====================================================================
//====================================================================
void Messenger :: send_uint64_msg(int dest, int compIndex, int inputIndex,
                                  double sendTime, double recvTime, uint64_t data)
{
    char buf[MAX_MSG_SIZE];  

    unsigned msg_type = Message_s :: M_UINT64;
    int isTick = 0;  //time unit for sendTime/recvTime is not tick

    int position = 0;

    MPI_Pack(&msg_type, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&compIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&inputIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&isTick, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&sendTime, 1, MPI_DOUBLE, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&recvTime, 1, MPI_DOUBLE, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&data, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);

    send_message(dest, buf, position);

    #ifdef DBG_MSG
    #endif

}


//====================================================================
//====================================================================
void Messenger :: send_serial_msg(int dest, int compIndex, int inputIndex,
				  Ticks_t sendTick, Ticks_t recvTick, unsigned char* data, int len)
{
    char buf[MAX_MSG_SIZE];  

    unsigned msg_type = Message_s :: M_SERIAL;
    int isTick = 1;  //time unit for sendTime/recvTime is tick

    int position = 0;

    MPI_Pack(&msg_type, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&compIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&inputIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&isTick, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    //Ticks_t == uint64_t
    MPI_Pack(&sendTick, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&recvTick, 1, MPI_UNSIGNED_LONG_LONG, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&len, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(data, len, MPI_UNSIGNED_CHAR, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);

    send_message(dest, buf, position);

    #ifdef DBG_MSG
    #endif

}


//====================================================================
//====================================================================
void Messenger :: send_serial_msg(int dest, int compIndex, int inputIndex,
                                  double sendTime, double recvTime, unsigned char* data, int len)
{
    char buf[MAX_MSG_SIZE];  

    unsigned msg_type = Message_s :: M_SERIAL;
    int isTick = 0;  //time unit for sendTime/recvTime is not tick

    int position = 0;

    MPI_Pack(&msg_type, 1, MPI_UNSIGNED, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&compIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&inputIndex, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&isTick, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&sendTime, 1, MPI_DOUBLE, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&recvTime, 1, MPI_DOUBLE, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(&len, 1, MPI_INT, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);
    MPI_Pack(data, len, MPI_UNSIGNED_CHAR, buf, MAX_MSG_SIZE, &position, MPI_COMM_WORLD);

    send_message(dest, buf, position);

    #ifdef DBG_MSG
    #endif

}


//====================================================================
//====================================================================
void Messenger :: send_message(int dest, char* buf, int position)
{
    if(MPI_Send(buf, position, MPI_PACKED, dest, MSG_TAG, MPI_COMM_WORLD) !=
                                                    MPI_SUCCESS) {
        cerr << "send_message failed!" << endl;
        exit(-1);
    }

    m_numSent++;
}


//====================================================================
//====================================================================
void Messenger :: start_irecv()
{
    if(m_irecv_started)
        return;

    m_buf = new char*[m_nodeSize];
    for(int i=0; i<m_nodeSize; i++) {
        m_buf[i] = new char[MAX_MSG_SIZE];
    }

    m_requests = new MPI_Request[m_nodeSize];

    for(int i=0; i<m_nodeSize; i++) {
	MPI_Irecv(m_buf[i], MAX_MSG_SIZE, MPI_CHAR, i, MSG_TAG, MPI_COMM_WORLD, &m_requests[i]);
    }

    m_irecv_started = true;
}


//====================================================================
//====================================================================
Message_s& Messenger :: irecv_message(int* received)
{
    assert(m_irecv_started == true);

    int index=0;
    *received = 0;
    MPI_Status status;
    MPI_Testany(m_nodeSize, m_requests, &index, received, &status);
    if(*received != 0) { 
	unpack_message(m_buf[index]);

	m_requests[index]=0;
	MPI_Irecv(m_buf[index], MAX_MSG_SIZE, MPI_CHAR, index, MSG_TAG, MPI_COMM_WORLD,
	          &m_requests[index]);
	m_numReceived++;
    }
    else {
        //no message available; do nothing
    }
    return m_msg;
}


//====================================================================
//====================================================================
Message_s& Messenger :: unpack_message(char* buf)
{
    int position;
    //char buf[MAX_MSG_SIZE];
    //MPI_Status status;
    //message_s msg;

    //MPI_Recv(buf, MAX_MSG_SIZE, MPI_PACKED, MPI_ANY_SOURCE, MSG_TAG, MPI_COMM_WORLD, &status);
 
    position = 0;
    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.type), 1, MPI_UNSIGNED, MPI_COMM_WORLD); 

    switch(m_msg.type) {
	case Message_s :: M_UINT32:
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.compIndex), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.inputIndex), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.isTick), 1, MPI_INT, MPI_COMM_WORLD);
	    if(m_msg.isTick == 0) {
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.sendTime), 1, MPI_DOUBLE, MPI_COMM_WORLD);
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.recvTime), 1, MPI_DOUBLE, MPI_COMM_WORLD);
	    }
	    else {
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.sendTick), 1,
		           MPI_UNSIGNED_LONG_LONG, MPI_COMM_WORLD);
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.recvTick), 1,
		           MPI_UNSIGNED_LONG_LONG, MPI_COMM_WORLD);
	    }

	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.uint32_data), 1, MPI_UNSIGNED,
	                                                             MPI_COMM_WORLD);
	break;
	case Message_s :: M_UINT64:
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.compIndex), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.inputIndex), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.isTick), 1, MPI_INT, MPI_COMM_WORLD);
	    if(m_msg.isTick == 0) {
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.sendTime), 1, MPI_DOUBLE, MPI_COMM_WORLD);
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.recvTime), 1, MPI_DOUBLE, MPI_COMM_WORLD);
	    }
	    else {
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.sendTick), 1,
		           MPI_UNSIGNED_LONG_LONG, MPI_COMM_WORLD);
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.recvTick), 1,
		           MPI_UNSIGNED_LONG_LONG, MPI_COMM_WORLD);
	    }

	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.uint64_data), 1, MPI_UNSIGNED_LONG_LONG,
	                                                             MPI_COMM_WORLD);
	break;
	case Message_s :: M_SERIAL:
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.compIndex), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.inputIndex), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.isTick), 1, MPI_INT, MPI_COMM_WORLD);
	    if(m_msg.isTick == 0) {
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.sendTime), 1, MPI_DOUBLE, MPI_COMM_WORLD);
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.recvTime), 1, MPI_DOUBLE, MPI_COMM_WORLD);
	    }
	    else {
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.sendTick), 1,
		           MPI_UNSIGNED_LONG_LONG, MPI_COMM_WORLD);
		MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.recvTick), 1,
		           MPI_UNSIGNED_LONG_LONG, MPI_COMM_WORLD);
	    }

	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.data_len), 1, MPI_INT, MPI_COMM_WORLD);
	    MPI_Unpack(buf, MAX_MSG_SIZE, &position, &(m_msg.data), m_msg.data_len, MPI_UNSIGNED_CHAR,
	                                                             MPI_COMM_WORLD);
	break;

	default:
	    cerr << "Unknown message type: " << m_msg.type << endl;
	    exit(1);
    }//switch

    return m_msg;
}





Messenger TheMessenger;

} //namespace kernel
} //namespace manifold

#endif //#ifndef NO_MPI





